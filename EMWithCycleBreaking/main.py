# # Add in documentation as you have more of it.

# class GraphEM:

# 	def __init__(self):
# 		"""Description of the class variables:
# 		self.n: Number of nodes in the graph
# 		self.edges: A list of undirected edges (represented as tuples) in the
# 			graph.
# 		self.workers: A set of worker indices.
# 		"""
# 		self.n = 0
# 		self.edges = []
# 		self.workers = set()

# 		graph = self.readGraph('graphSpecification.txt')
# 		observations = self.readObservations('observations.txt')
# 		self.EM_v1(graph, observations)
# 		return

# 	def readGraph(self, graphFile):
# 		"""Reads the graph provided in the graphFile. The format of the graph
# 		file should be the following: The first line should contain the number
# 		of nodes (n) in the graph. Note that the nodes should be zero indexed, 
# 		so that the actual node indices go up to (n-1). The n lines following 
# 		the first should should contain a comma separated list of the nodes
# 		that share an edge with the node. For example, the following lines
# 		show a triagular graph:
# 		3
# 		1,2
# 		0,2
# 		0,1
# 		Input Args:-
# 		graphFile: the location of the input file.
# 		Output Args:-
# 		graphObj: Returns the graph object as a dictionary where key represen-
# 			ts the node index, and the value is a set of neighbouring
# 			nodes.
# 		"""

# 		with open(graphFile) as f:
# 			self.n = int(f.readline().rstrip())
# 			graphObj = {i:[] for i in xrange(self.n)}

# 			for i in xrange(self.n):
# 				graphObj[i] = [int(x) for x in f.readline().rstrip().split(',')]
# 				[self.edges.append((i,x)) for x in graphObj[i]]

# 		return graphObj

# 	def readObservations(self, obsFile):
# 		"""Reads fuzzy observations about the directions of the graph. The
# 		observations are specified in the following format: let an observation
# 		be generated by worker k (or the random noise variable k). The observ-
# 		ations provided by this worker should be written like: 
# 		k, {from node-index}, {to node-index}
# 		Input Args:-
# 		obsFile: Path to observation file
# 		Output Args:-
# 		observations: A dicitionary with 2*m keys (m is the number of edges), 
# 			where both directions of edges are present in the dicti-
# 			onary as a tuple of ({from node}, {to node}). The values
# 			are a list of of workers/random variables that produce
# 			that observation.
# 		"""

# 		observations = {}
# 		for e in self.edges:
# 			observations[e] = []
# 			observations[(e[1], e[0])] = []

# 		with open(obsFile) as f:
# 			for line in f:
# 				(worker, fromNode, toNode) = [int(x) for x in line.rstrip().split(',')]
# 				observations[(fromNode, toNode)].append(worker)
# 				self.workers.add(worker)


# 		return observations


# 	# def EM(self, graph, observations):
# 	# 	"""Performs the standard EM algorithm. In the E step, we estimate the
# 	# 	directions of the edges, and then perform cycle breaking. In the M
# 	# 	step, we re-estimate edge difficulties and worker skills.
# 	# 	Input Args:-
# 	# 	graph: Graph returned by the readGraph function.
# 	# 	observations: Observations returned by the readObseervations function.
# 	# 	Output Args:-
# 	# 	graph: The graph as a list of edge-tuples. Edges in the correct 
# 	# 		direction.
# 	# 	workerError: A dictionary with key=workerID, and value=skill paramter.
# 	# 	edgeDifficulty: A dictionary with key=edge tuple, and value=difficulty
# 	# 		of that edge.
# 	# 	"""

# 	# 	# Initializing worker skill and edge difficulty.

# 	def Estep_v1(self, graph, observations, difficulties):

# 		determined_edges = {}

# 		for e in self.edges:
# 			reverse_e = (e[1], e[0])
# 			if e in determined_edges.keys() or reverse_e in determined_edges.keys():
# 				continue
# 			d = difficulties[e]

# 			forward_prob = 1
# 			[forward_prob/(1+d) for _ in observations[e]]
# 			[forward_prob*d/(1+d) for _ in observations[reverse_e]]

# 			backward_prob = 1
# 			[backward_prob/(1+d) for _ in observations[reverse_e]]
# 			[backward_prob*d/(1+d) for _ in observations[e]]

# 			if forward_prob>backward_prob:
# 				determined_edges[e] = forward_prob*1.0/(forward_prob+backward_prob)
# 			else:
# 				determined_edges[reverse_e] = backward_prob*1.0/(forward_prob+backward_prob)

# 		# Cycle Breaking

# 		return determined_edges


# 	def Mstep_v1(self, directed_graph, observations):

# 		difficulties = {}

# 		for e in self.edges:
# 			reverse_e = (e[1], e[0])

# 			if e in directed_graph.keys():
# 				true_side = e
# 				false_side = reverse_e
# 			else:
# 				true_side = reverse_e
# 				false_side = e

# 			diff = (len(observations[true_side])+0.0001)*1.0/(len(observations[true_side])+len(observations[false_side]))
# 			difficulties[true_side] = diff
# 			difficulties[false_side] = diff

# 		return difficulties




# 	def EM_v1(self, graph, observations):
# 		"""Performs the standard EM algorithm. 
# 		v1: The accuracy function is a function of difficulty only, and the
# 			is of the form 1/(1+d).
# 		In the E step, we estimate the directions of the edges, and then 
# 		perform cycle breaking. In the M step, we re-estimate edge 
# 		difficulties and worker skills.
# 		Input Args:-
# 		graph: Graph returned by the readGraph function.
# 		observations: Observations returned by the readObseervations function.
# 		Output Args:-
# 		graph: The graph with edges in the correct direction. The format of
# 			the graph is similar to the input graph, except that each line
# 			index is the 'from' node, and only 'to' nodes are listed in each
# 			line.
# 		edgeDifficulty: A dictionary with key=edge tuple, and value=difficulty
# 			of that edge.
# 		"""

# 		# Initializing edge difficulty.
# 		edgeDifficulty = {x:0.5 for x in self.edges}

# 		old_graph = 0
# 		iter = 0
# 		while(True):

# 			new_graph = self.Estep_v1(graph, observations, edgeDifficulty)
# 			edgeDifficulties = self.Mstep_v1(new_graph, observations)

# 			if new_graph==old_graph:
# 				break
# 			else:
# 				old_graph = new_graph

# 			iter += 1

# 		print iter 


# graphEM = GraphEM()


from random import uniform
from pprint import pprint
from randomGraphGenerator import ProblemInstance


# Add in documentation as you have more of it.

f = open('results_baselinev3.txt', 'w')

class GraphEM:

	def __init__(self, flag, n, edges, workers, graph, observations, trueDAG, trueDiff, numNodes, c):
		"""Description of the class variables:
		self.n: Number of nodes in the graph
		self.edges: A list of undirected edges (represented as tuples) in the
			graph.
		self.workers: A set of worker indices.
		"""

		print "Baseline", numNodes, c

		if flag:
			self.n = 0
			self.edges = []
			self.workers = set()

			graph = self.readGraph('graphSpecification.txt')
			observations = self.readObservations('observations.txt')
		else:
			self.n = n
			self.edges = edges
			self.workers = workers


		edgeDifficulty, new_graph = self.EM_v1(graph, observations)

		trueEdges = set()
		for k,v in trueDAG.items():
			for i in v:
				trueEdges.add((k,i))

		newEdges = set(new_graph.keys())

		# print len(new_graph)

		f.write("%d, %.4f\n" % (n, len(newEdges.intersection(trueEdges))/(1.0*len(trueEdges))))

		print len(newEdges), len(trueEdges)

		return 

	def readGraph(self, graphFile):
		"""Reads the graph provided in the graphFile. The format of the graph
		file should be the following: The first line should contain the number
		of nodes (n) in the graph. Note that the nodes should be zero indexed, 
		so that the actual node indices go up to (n-1). The n lines following 
		the first should should contain a comma separated list of the nodes
		that share an edge with the node. For example, the following lines
		show a triagular graph:
		3
		1,2
		0,2
		0,1
		Input Args:-
		graphFile: the location of the input file.
		Output Args:-
		graphObj: Returns the graph object as a dictionary where key represen-
			ts the node index, and the value is a set of neighbouring
			nodes.
		"""

		with open(graphFile) as f:
			self.n = int(f.readline().rstrip())
			graphObj = {i:[] for i in xrange(self.n)}

			for i in xrange(self.n):
				graphObj[i] = [int(x) for x in f.readline().rstrip().split(',')]
				[self.edges.append((i,x)) for x in graphObj[i]]

		return graphObj

	def readObservations(self, obsFile):
		"""Reads fuzzy observations about the directions of the graph. The
		observations are specified in the following format: let an observation
		be generated by worker k (or the random noise variable k). The observ-
		ations provided by this worker should be written like: 
		k, {from node-index}, {to node-index}
		Input Args:-
		obsFile: Path to observation file
		Output Args:-
		observations: A dicitionary with 2*m keys (m is the number of edges), 
			where both directions of edges are present in the dicti-
			onary as a tuple of ({from node}, {to node}). The values
			are a list of of workers/random variables that produce
			that observation.
		"""

		observations = {}
		for e in self.edges:
			observations[e] = []
			observations[(e[1], e[0])] = []

		with open(obsFile) as f:
			for line in f:
				(worker, fromNode, toNode) = [int(x) for x in line.rstrip().split(',')]
				observations[(fromNode, toNode)].append(worker)
				self.workers.add(worker)


		return observations


	# def EM(self, graph, observations):
	# 	"""Performs the standard EM algorithm. In the E step, we estimate the
	# 	directions of the edges, and then perform cycle breaking. In the M
	# 	step, we re-estimate edge difficulties and worker skills.
	# 	Input Args:-
	# 	graph: Graph returned by the readGraph function.
	# 	observations: Observations returned by the readObseervations function.
	# 	Output Args:-
	# 	graph: The graph as a list of edge-tuples. Edges in the correct 
	# 		direction.
	# 	workerError: A dictionary with key=workerID, and value=skill paramter.
	# 	edgeDifficulty: A dictionary with key=edge tuple, and value=difficulty
	# 		of that edge.
	# 	"""

	# 	# Initializing worker skill and edge difficulty.

	def Estep_v1(self, graph, observations, difficulties):

		determined_edges = {}

		for e in self.edges:
			reverse_e = (e[1], e[0])
			if e in determined_edges.keys() or reverse_e in determined_edges.keys():
				continue
			d = difficulties[e]

			forward_prob = 1
			for x in observations[e]:
				forward_prob *= (1.0*d)
			for x in observations[reverse_e]:
				forward_prob *= (1-d)

			backward_prob = 1
			for x in observations[reverse_e]:
				backward_prob *= (1.0*d)
			for x in observations[e]:
				backward_prob *= 1.0*(1-d)

			if forward_prob>backward_prob:
				determined_edges[e] = forward_prob*1.0/(forward_prob+backward_prob)
			else:
				determined_edges[reverse_e] = backward_prob*1.0/(forward_prob+backward_prob)

		# Cycle Breaking

		return determined_edges


	def Mstep_v1(self, directed_graph, observations):

		difficulties = {}

		for e in self.edges:
			reverse_e = (e[1], e[0])

			if e in directed_graph.keys():
				true_side = e
				false_side = reverse_e
			else:
				true_side = reverse_e
				false_side = e

			diff = (len(observations[true_side])+0.0001)*1.0/(len(observations[true_side])+len(observations[false_side]))
			difficulties[true_side] = diff
			difficulties[false_side] = diff

		return difficulties




	def EM_v1(self, graph, observations):
		"""Performs the standard EM algorithm. 
		v1: The accuracy function is a function of difficulty only, and the
			is of the form 1/(1+d).
		In the E step, we estimate the directions of the edges, and then 
		perform cycle breaking. In the M step, we re-estimate edge 
		difficulties and worker skills.
		Input Args:-
		graph: Graph returned by the readGraph function.
		observations: Observations returned by the readObseervations function.
		Output Args:-
		graph: The graph with edges in the correct direction. The format of
			the graph is similar to the input graph, except that each line
			index is the 'from' node, and only 'to' nodes are listed in each
			line.
		edgeDifficulty: A dictionary with key=edge tuple, and value=difficulty
			of that edge.
		"""

		# Initializing edge difficulty.
		edgeDifficulty = {x:uniform(0,1) for x in self.edges}

		old_graph = 0
		iter = 0
		while(True):

			new_graph = self.Estep_v1(graph, observations, edgeDifficulty)
			edgeDifficulties = self.Mstep_v1(new_graph, observations)

			if new_graph==old_graph:
				break
			else:
				old_graph = new_graph

			iter += 1

		return edgeDifficulty, new_graph


